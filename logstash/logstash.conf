input {
  tcp {
    port => 514
    type => syslog
  }
  udp {
    port => 514
    type => syslog
  }
  tcp {
    port => 24224
    codec => fluent
  }
  gelf {
    port => 12201
    type => gelf
  }
}

filter {

  # match nginx_access first
  grok {
    match => {
    "message" => '%{SYSLOG5424PRI:syslog5424_pri}+(?:%{TIMESTAMP_ISO8601:syslog_timestamp}|-) default docker/+(?:%{HOSTNAME:containerid}|-)\[+(?:%{POSINT:pid}|-)\]: %{IP:client} - (?:%{NOTSPACE:http_user}|-) \[%{HTTPDATE:http_timestamp}\] "%{WORD:http_method} %{URIPATHPARAM:http_request} HTTP/%{NUMBER:http_version}" %{NUMBER:http_code} %{NUMBER:http_bytes_sent} (?:%{QUOTEDSTRING:http_referer}|-) (?:%{QUOTEDSTRING:http_user_agent}|-) "(?:%{IP:x_forwarded_for}|-)"+%{GREEDYDATA:msg}'
    }
    add_tag => "nginx_access"
  }

  # failed to match nginx_access log, so parse as nginx_error
  if "_grokparsefailure" in [tags] {
    mutate { remove_tag => [ "_grokparsefailure" ] }
    grok {
      match => {
        "message" => '%{SYSLOG5424PRI:syslog5424_pri}+(?:%{TIMESTAMP_ISO8601:syslog_timestamp}|-) default docker/+(?:%{HOSTNAME:containerid}|-)\[+(?:%{POSINT:pid}|-)\]: %{GREEDYDATA:msg}'
      }
      add_tag => "nginx_error"
    }
  }


  if [type] == "syslog" {
    syslog_pri { }
    date { match => [ "syslog_timestamp", "ISO8601"] }
    if !("_grokparsefailure" in [tags]) {
      mutate {
        replace => [ "@source_host", "%{syslog_hostname}" ]
        replace => [ "@message", "%{syslog_message}" ]
        remove_field => [ "message" ] # redundant data at this point
      }
    }
    mutate {
      remove_field => [ "syslog_hostname", "syslog_message", "syslog_timestamp" ]
    }
  }

}

output {
  elasticsearch { hosts => ["elasticsearch"] }
  stdout { codec => rubydebug }
}
